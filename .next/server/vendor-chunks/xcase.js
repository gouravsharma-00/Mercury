"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xcase";
exports.ids = ["vendor-chunks/xcase"];
exports.modules = {

/***/ "(rsc)/./node_modules/xcase/es5/index.js":
/*!*****************************************!*\
  !*** ./node_modules/xcase/es5/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction isLower(char) {\n  return char >= 0x61 /* 'a' */ && char <= 0x7a /* 'z' */;\n}\n\nfunction isUpper(char) {\n  return char >= 0x41 /* 'A' */ && char <= 0x5a /* 'Z' */;\n}\n\nfunction isDigit(char) {\n  return char >= 0x30 /* '0' */ && char <= 0x39 /* '9' */;\n}\n\nfunction toUpper(char) {\n  return char - 0x20;\n}\n\nfunction toUpperSafe(char) {\n  if (isLower(char)) {\n    return char - 0x20;\n  }\n  return char;\n}\n\nfunction toLower(char) {\n  return char + 0x20;\n}\n\nfunction camelize$1(str, separator) {\n  var firstChar = str.charCodeAt(0);\n  if (isDigit(firstChar) || isUpper(firstChar) || firstChar == separator) {\n    return str;\n  }\n  var out = [];\n  var changed = false;\n  if (isUpper(firstChar)) {\n    changed = true;\n    out.push(toLower(firstChar));\n  } else {\n    out.push(firstChar);\n  }\n\n  var length = str.length;\n  for (var i = 1; i < length; ++i) {\n    var c = str.charCodeAt(i);\n    if (c === separator) {\n      changed = true;\n      c = str.charCodeAt(++i);\n      if (isNaN(c)) {\n        return str;\n      }\n      out.push(toUpperSafe(c));\n    } else {\n      out.push(c);\n    }\n  }\n  return changed ? String.fromCharCode.apply(undefined, out) : str;\n}\n\nfunction decamelize$1(str, separator) {\n  var firstChar = str.charCodeAt(0);\n  if (!isLower(firstChar)) {\n    return str;\n  }\n  var length = str.length;\n  var changed = false;\n  var out = [];\n  for (var i = 0; i < length; ++i) {\n    var c = str.charCodeAt(i);\n    if (isUpper(c)) {\n      out.push(separator);\n      out.push(toLower(c));\n      changed = true;\n    } else {\n      out.push(c);\n    }\n  }\n  return changed ? String.fromCharCode.apply(undefined, out) : str;\n}\n\nfunction pascalize$1(str, separator) {\n  var firstChar = str.charCodeAt(0);\n  if (isDigit(firstChar) || firstChar == separator) {\n    return str;\n  }\n  var length = str.length;\n  var changed = false;\n  var out = [];\n  for (var i = 0; i < length; ++i) {\n    var c = str.charCodeAt(i);\n    if (c === separator) {\n      changed = true;\n      c = str.charCodeAt(++i);\n      if (isNaN(c)) {\n        return str;\n      }\n      out.push(toUpperSafe(c));\n    } else if (i === 0 && isLower(c)) {\n      changed = true;\n      out.push(toUpper(c));\n    } else {\n      out.push(c);\n    }\n  }\n  return changed ? String.fromCharCode.apply(undefined, out) : str;\n}\n\nfunction depascalize$1(str, separator) {\n  var firstChar = str.charCodeAt(0);\n  if (!isUpper(firstChar)) {\n    return str;\n  }\n  var length = str.length;\n  var changed = false;\n  var out = [];\n  for (var i = 0; i < length; ++i) {\n    var c = str.charCodeAt(i);\n    if (isUpper(c)) {\n      if (i > 0) {\n        out.push(separator);\n      }\n      out.push(toLower(c));\n      changed = true;\n    } else {\n      out.push(c);\n    }\n  }\n  return changed ? String.fromCharCode.apply(undefined, out) : str;\n}\n\nfunction shouldProcessValue(value) {\n  return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && !(value instanceof Date) && !(value instanceof Function);\n}\n\nfunction processKeys(obj, fun, opts) {\n  var obj2 = void 0;\n  if (obj instanceof Array) {\n    obj2 = [];\n  } else {\n    if (typeof obj.prototype !== 'undefined') {\n      // return non-plain object unchanged\n      return obj;\n    }\n    obj2 = {};\n  }\n  for (var key in obj) {\n    var value = obj[key];\n    if (typeof key === 'string') key = fun(key, opts && opts.separator);\n    if (shouldProcessValue(value)) {\n      obj2[key] = processKeys(value, fun, opts);\n    } else {\n      obj2[key] = value;\n    }\n  }\n  return obj2;\n}\n\nfunction processKeysInPlace(obj, fun, opts) {\n  var keys = Object.keys(obj);\n  for (var idx = 0; idx < keys.length; ++idx) {\n    var key = keys[idx];\n    var value = obj[key];\n    var newKey = fun(key, opts && opts.separator);\n    if (newKey !== key) {\n      delete obj[key];\n    }\n    if (shouldProcessValue(value)) {\n      obj[newKey] = processKeys(value, fun, opts);\n    } else {\n      obj[newKey] = value;\n    }\n  }\n  return obj;\n}\n\nfunction camelize$$1(str, separator) {\n  return camelize$1(str, separator && separator.charCodeAt(0) || 0x5f /* _ */);\n}\n\nfunction decamelize$$1(str, separator) {\n  return decamelize$1(str, separator && separator.charCodeAt(0) || 0x5f /* _ */);\n}\n\nfunction pascalize$$1(str, separator) {\n  return pascalize$1(str, separator && separator.charCodeAt(0) || 0x5f /* _ */);\n}\n\nfunction depascalize$$1(str, separator) {\n  return depascalize$1(str, separator && separator.charCodeAt(0) || 0x5f /* _ */);\n}\n\nfunction camelizeKeys(obj, opts) {\n  opts = opts || {};\n  if (!shouldProcessValue(obj)) return obj;\n  if (opts.inPlace) return processKeysInPlace(obj, camelize$$1, opts);\n  return processKeys(obj, camelize$$1, opts);\n}\n\nfunction decamelizeKeys(obj, opts) {\n  opts = opts || {};\n  if (!shouldProcessValue(obj)) return obj;\n  if (opts.inPlace) return processKeysInPlace(obj, decamelize$$1, opts);\n  return processKeys(obj, decamelize$$1, opts);\n}\n\nfunction pascalizeKeys(obj, opts) {\n  opts = opts || {};\n  if (!shouldProcessValue(obj)) return obj;\n  if (opts.inPlace) return processKeysInPlace(obj, pascalize$$1, opts);\n  return processKeys(obj, pascalize$$1, opts);\n}\n\nfunction depascalizeKeys(obj, opts) {\n  opts = opts || {};\n  if (!shouldProcessValue(obj)) return obj;\n  if (opts.inPlace) return processKeysInPlace(obj, depascalize$$1, opts);\n  return processKeys(obj, depascalize$$1, opts);\n}\n\nexports.camelize = camelize$$1;\nexports.decamelize = decamelize$$1;\nexports.pascalize = pascalize$$1;\nexports.depascalize = depascalize$$1;\nexports.camelizeKeys = camelizeKeys;\nexports.decamelizeKeys = decamelizeKeys;\nexports.pascalizeKeys = pascalizeKeys;\nexports.depascalizeKeys = depascalizeKeys;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveGNhc2UvZXM1L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFN0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQix1QkFBdUIiLCJzb3VyY2VzIjpbIi9ob21lL2JlbGlzYXJpdXMvZGV2ZWxvcGVyL21lcmN1cnkvbm9kZV9tb2R1bGVzL3hjYXNlL2VzNS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBpc0xvd2VyKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPj0gMHg2MSAvKiAnYScgKi8gJiYgY2hhciA8PSAweDdhIC8qICd6JyAqLztcbn1cblxuZnVuY3Rpb24gaXNVcHBlcihjaGFyKSB7XG4gIHJldHVybiBjaGFyID49IDB4NDEgLyogJ0EnICovICYmIGNoYXIgPD0gMHg1YSAvKiAnWicgKi87XG59XG5cbmZ1bmN0aW9uIGlzRGlnaXQoY2hhcikge1xuICByZXR1cm4gY2hhciA+PSAweDMwIC8qICcwJyAqLyAmJiBjaGFyIDw9IDB4MzkgLyogJzknICovO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgLSAweDIwO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyU2FmZShjaGFyKSB7XG4gIGlmIChpc0xvd2VyKGNoYXIpKSB7XG4gICAgcmV0dXJuIGNoYXIgLSAweDIwO1xuICB9XG4gIHJldHVybiBjaGFyO1xufVxuXG5mdW5jdGlvbiB0b0xvd2VyKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgKyAweDIwO1xufVxuXG5mdW5jdGlvbiBjYW1lbGl6ZSQxKHN0ciwgc2VwYXJhdG9yKSB7XG4gIHZhciBmaXJzdENoYXIgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgaWYgKGlzRGlnaXQoZmlyc3RDaGFyKSB8fCBpc1VwcGVyKGZpcnN0Q2hhcikgfHwgZmlyc3RDaGFyID09IHNlcGFyYXRvcikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoaXNVcHBlcihmaXJzdENoYXIpKSB7XG4gICAgY2hhbmdlZCA9IHRydWU7XG4gICAgb3V0LnB1c2godG9Mb3dlcihmaXJzdENoYXIpKTtcbiAgfSBlbHNlIHtcbiAgICBvdXQucHVzaChmaXJzdENoYXIpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjID09PSBzZXBhcmF0b3IpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICAgICBpZiAoaXNOYU4oYykpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHRvVXBwZXJTYWZlKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2goYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2VkID8gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSh1bmRlZmluZWQsIG91dCkgOiBzdHI7XG59XG5cbmZ1bmN0aW9uIGRlY2FtZWxpemUkMShzdHIsIHNlcGFyYXRvcikge1xuICB2YXIgZmlyc3RDaGFyID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIGlmICghaXNMb3dlcihmaXJzdENoYXIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaXNVcHBlcihjKSkge1xuICAgICAgb3V0LnB1c2goc2VwYXJhdG9yKTtcbiAgICAgIG91dC5wdXNoKHRvTG93ZXIoYykpO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5wdXNoKGMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlZCA/IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkodW5kZWZpbmVkLCBvdXQpIDogc3RyO1xufVxuXG5mdW5jdGlvbiBwYXNjYWxpemUkMShzdHIsIHNlcGFyYXRvcikge1xuICB2YXIgZmlyc3RDaGFyID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIGlmIChpc0RpZ2l0KGZpcnN0Q2hhcikgfHwgZmlyc3RDaGFyID09IHNlcGFyYXRvcikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPT09IHNlcGFyYXRvcikge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIGlmIChpc05hTihjKSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2godG9VcHBlclNhZmUoYykpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCAmJiBpc0xvd2VyKGMpKSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIG91dC5wdXNoKHRvVXBwZXIoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQucHVzaChjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KHVuZGVmaW5lZCwgb3V0KSA6IHN0cjtcbn1cblxuZnVuY3Rpb24gZGVwYXNjYWxpemUkMShzdHIsIHNlcGFyYXRvcikge1xuICB2YXIgZmlyc3RDaGFyID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIGlmICghaXNVcHBlcihmaXJzdENoYXIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaXNVcHBlcihjKSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIG91dC5wdXNoKHNlcGFyYXRvcik7XG4gICAgICB9XG4gICAgICBvdXQucHVzaCh0b0xvd2VyKGMpKTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQucHVzaChjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KHVuZGVmaW5lZCwgb3V0KSA6IHN0cjtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc1ZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09ICdvYmplY3QnICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5cyhvYmosIGZ1biwgb3B0cykge1xuICB2YXIgb2JqMiA9IHZvaWQgMDtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgb2JqMiA9IFtdO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb2JqLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHJldHVybiBub24tcGxhaW4gb2JqZWN0IHVuY2hhbmdlZFxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgb2JqMiA9IHt9O1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIGtleSA9IGZ1bihrZXksIG9wdHMgJiYgb3B0cy5zZXBhcmF0b3IpO1xuICAgIGlmIChzaG91bGRQcm9jZXNzVmFsdWUodmFsdWUpKSB7XG4gICAgICBvYmoyW2tleV0gPSBwcm9jZXNzS2V5cyh2YWx1ZSwgZnVuLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqMltrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmoyO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5c0luUGxhY2Uob2JqLCBmdW4sIG9wdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBrZXlzLmxlbmd0aDsgKytpZHgpIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpZHhdO1xuICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgIHZhciBuZXdLZXkgPSBmdW4oa2V5LCBvcHRzICYmIG9wdHMuc2VwYXJhdG9yKTtcbiAgICBpZiAobmV3S2V5ICE9PSBrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFByb2Nlc3NWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIG9ialtuZXdLZXldID0gcHJvY2Vzc0tleXModmFsdWUsIGZ1biwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtuZXdLZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGNhbWVsaXplJCQxKHN0ciwgc2VwYXJhdG9yKSB7XG4gIHJldHVybiBjYW1lbGl6ZSQxKHN0ciwgc2VwYXJhdG9yICYmIHNlcGFyYXRvci5jaGFyQ29kZUF0KDApIHx8IDB4NWYgLyogXyAqLyk7XG59XG5cbmZ1bmN0aW9uIGRlY2FtZWxpemUkJDEoc3RyLCBzZXBhcmF0b3IpIHtcbiAgcmV0dXJuIGRlY2FtZWxpemUkMShzdHIsIHNlcGFyYXRvciAmJiBzZXBhcmF0b3IuY2hhckNvZGVBdCgwKSB8fCAweDVmIC8qIF8gKi8pO1xufVxuXG5mdW5jdGlvbiBwYXNjYWxpemUkJDEoc3RyLCBzZXBhcmF0b3IpIHtcbiAgcmV0dXJuIHBhc2NhbGl6ZSQxKHN0ciwgc2VwYXJhdG9yICYmIHNlcGFyYXRvci5jaGFyQ29kZUF0KDApIHx8IDB4NWYgLyogXyAqLyk7XG59XG5cbmZ1bmN0aW9uIGRlcGFzY2FsaXplJCQxKHN0ciwgc2VwYXJhdG9yKSB7XG4gIHJldHVybiBkZXBhc2NhbGl6ZSQxKHN0ciwgc2VwYXJhdG9yICYmIHNlcGFyYXRvci5jaGFyQ29kZUF0KDApIHx8IDB4NWYgLyogXyAqLyk7XG59XG5cbmZ1bmN0aW9uIGNhbWVsaXplS2V5cyhvYmosIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGlmICghc2hvdWxkUHJvY2Vzc1ZhbHVlKG9iaikpIHJldHVybiBvYmo7XG4gIGlmIChvcHRzLmluUGxhY2UpIHJldHVybiBwcm9jZXNzS2V5c0luUGxhY2Uob2JqLCBjYW1lbGl6ZSQkMSwgb3B0cyk7XG4gIHJldHVybiBwcm9jZXNzS2V5cyhvYmosIGNhbWVsaXplJCQxLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gZGVjYW1lbGl6ZUtleXMob2JqLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBpZiAoIXNob3VsZFByb2Nlc3NWYWx1ZShvYmopKSByZXR1cm4gb2JqO1xuICBpZiAob3B0cy5pblBsYWNlKSByZXR1cm4gcHJvY2Vzc0tleXNJblBsYWNlKG9iaiwgZGVjYW1lbGl6ZSQkMSwgb3B0cyk7XG4gIHJldHVybiBwcm9jZXNzS2V5cyhvYmosIGRlY2FtZWxpemUkJDEsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBwYXNjYWxpemVLZXlzKG9iaiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgaWYgKCFzaG91bGRQcm9jZXNzVmFsdWUob2JqKSkgcmV0dXJuIG9iajtcbiAgaWYgKG9wdHMuaW5QbGFjZSkgcmV0dXJuIHByb2Nlc3NLZXlzSW5QbGFjZShvYmosIHBhc2NhbGl6ZSQkMSwgb3B0cyk7XG4gIHJldHVybiBwcm9jZXNzS2V5cyhvYmosIHBhc2NhbGl6ZSQkMSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGRlcGFzY2FsaXplS2V5cyhvYmosIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGlmICghc2hvdWxkUHJvY2Vzc1ZhbHVlKG9iaikpIHJldHVybiBvYmo7XG4gIGlmIChvcHRzLmluUGxhY2UpIHJldHVybiBwcm9jZXNzS2V5c0luUGxhY2Uob2JqLCBkZXBhc2NhbGl6ZSQkMSwgb3B0cyk7XG4gIHJldHVybiBwcm9jZXNzS2V5cyhvYmosIGRlcGFzY2FsaXplJCQxLCBvcHRzKTtcbn1cblxuZXhwb3J0cy5jYW1lbGl6ZSA9IGNhbWVsaXplJCQxO1xuZXhwb3J0cy5kZWNhbWVsaXplID0gZGVjYW1lbGl6ZSQkMTtcbmV4cG9ydHMucGFzY2FsaXplID0gcGFzY2FsaXplJCQxO1xuZXhwb3J0cy5kZXBhc2NhbGl6ZSA9IGRlcGFzY2FsaXplJCQxO1xuZXhwb3J0cy5jYW1lbGl6ZUtleXMgPSBjYW1lbGl6ZUtleXM7XG5leHBvcnRzLmRlY2FtZWxpemVLZXlzID0gZGVjYW1lbGl6ZUtleXM7XG5leHBvcnRzLnBhc2NhbGl6ZUtleXMgPSBwYXNjYWxpemVLZXlzO1xuZXhwb3J0cy5kZXBhc2NhbGl6ZUtleXMgPSBkZXBhc2NhbGl6ZUtleXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/xcase/es5/index.js\n");

/***/ })

};
;